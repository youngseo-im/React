# 클래스 컴포넌트의 라이프 사이클과 useEffect 차이점

1. 모든 컴포넌트는 여러 종류의 "생명주기 메서드를" 가지며 이 메서드를 오버라이딩하여 특정 시점에 코드가 실행되도록 설정 할 수 있다고 React는 말합니다, 
2. 이번 챕터에서는 기존에 클래스 생명주기 메서드는 어떻게 이루어져 있었고 또 어떤식으로 변화되었고 그리고 Basic hook에서 마운트 사이클은 어떤식으로 이루어지는지 알아보도록 하겠습니다.

## 생명주기는 크게 3단계로 나누어 집니다

1. <img width="1021" alt="스크린샷 2020-12-24 오후 3 34 14" src="https://user-images.githubusercontent.com/75972718/103067153-a6a7f680-45fd-11eb-8948-40464477adfa.png">

2. 아래 목록에서 자주 사용되는 생명주기 메서드는 **진하게** 표시했습니다. 나머지 것들은 상대적으로 자주 사용되지 않습니다.

3. 앞에 UNSAFE_ 가 붙은 메서드는 기존에 사용되었지만 이제는 사용하면 안되는 메서드를 말합니다.

4. ### Mounting

   1. 여기에 해당하는 메서드들은 인스턴스가 생성되어 DOM상에 삽입될 때에 순서대로 호출됩니다.

   2. **constructor()**

      1. 메서드를 바인딩 하거나 state를 초기화하는 작업이 없다면, 해당 React 컴포넌트에는 생성자를 구현하지 않아도 됩니다.
      2. React.Component를 상속한 컴포넌트의 constructor를 구현할 때에는 다른 구문에 앞서 super(props)를 호출해야 합니다 그렇지 않으면 this.props가 constructor 내에서 정의되지 않기때문에 버그로 이어질 수 있습니다 .
      3. React에서 constructor는 보통 아래의 두 가지 목적을 위해서 사용됩니다.
         1. This.state에 객체를 할당하여 지역 state를 초기화
         2. 인스턴스에 이벤트 처리 메서드를 바인딩
      4. Constructor() 내부에서 setState()를 호출하면 안됩니다. 컴포넌트에 지역 state가 필요하다면 앞서 말한것 처럼 constructor 내부에 this.state에 초기 state 값을 할당하면 됩니다.
      5. <img width="658" alt="스크린샷 2020-12-24 오후 3 43 10" src="https://user-images.githubusercontent.com/75972718/103067705-e6231280-45fe-11eb-86f6-3b29c9f54f34.png">
      6. 이곳은 유일하게 this.state를 직접 할당할 수 있는 곳이기 때문에 그 외에 메서드에서는 This.setState()를 사용해야 합니다.
      7. 주의 할 점은 state에 props를 복사하는 행위를 하면 안됩니다 코드로 보면 다음과 같습니다.
      8. <img width="658" alt="스크린샷 2020-12-24 오후 3 47 04" src="https://user-images.githubusercontent.com/75972718/103067957-71040d00-45ff-11eb-939f-e1a3835c6bca.png">

   3. UNSAFE_componentWillMount() ==>  변경 Static getDerivedStateFromProps()

      1. 최초 마운트 시와 갱신 시 모두에서 render 메서드를 호출하기 직전에 호출됩니다.
      2. state를 갱신하기 위한 객체를 반환하거나, null을 반환하여 아무 것도 갱신하지 않을 수 있습니다.
      3. 이 메서드는 시간이 흐름에 따라 편하는 props에 state가 의존하는 아주 드문 사례를 위하여 존재합니 예를 들어 이전과 현재의 자식 엘리먼트를 비교하는 Transition과 같은 컴포넌트를 구현할 때에 편리하게 사용할 수 있습니다.
      4. state를 끌어오면 코드가 장황해지고, 이로 인하여 컴포넌트를 이해하기 어려워집니다. 보다 간단한 다른 대안들에 익숙해지는 것을 권장합니다.
         1. props 변화에 대응한 부수 효과를 발생시켜야 한다면 componentDidUpdate 메서드를 대신해서 사용하세요.
         2. props가 변화했을 때에만 일부 데이터를 다시 계산하고 싶다면 Memoization Helper를 대신 사용하세요.
         3. props가 변화할 때에 일부 state를 재설정하고 싶다면 controlled component 또는 key를 사용하는 uncontrolled component로 만들어서 사용하세요 
      5. 이 메서드는 이유와 상관없이 렌더링 때마다 매번 실행되기 때문에 주의해야하는데 이 메서드의 경우 부모 컴포넌트가 다시 렌더링을 발생시켰을때에만 실행되고, 해당 컴포넌트 내에서 지역적인 setState가 발생한 경우에는 실행되지 않습니다 . 

   4. **render()**

      1. 이 메서드는 클래스 컴포넌트에서 반드시 구현되어야 하는 유일한 메서드입니다.
      2. 이 메서드가 호출되면 this.props와 this.state의 값을 활용하여 아래의 것 중 하나를 반환해야 합니다 .
      3. **React엘리먼트**
      4. **배열과 Fragment**
      5. **Portal**
      6. **문자열과 숫자**
      7. **Bollean 또는 null**
      8. render()함수는 순수 함수여야 합니다 즉, 컴포넌트의 state를 변경하지 않고, 호출될 때마다 동일한 결과를 반환해야 하며, 브라우저와 직접적으로 상호작용을 하지 않습니다 .

   5. **componentDidMount()**

      1. 컴포넌트가 마운트된 직후 즉 트리에 삽입된 직후에 호출됩니다.
      2. DOM노드가 있어야 하는 초기화 작업은 이 메서드에서 이루어지면 됩니다.
      3. 외부에서 데이터를 불러와야 한다면, 네트워크 요청을 보내기 적절한 위치입니다.
      4. 이 메서드에 만약 무한루프를 도는 코드가 존재한다면 꼭 componentWillUnmount에서 무한루프를 해제하는 작업을 반드시 수행해야합니다 만약에 그 무한루프가 겉으로 보여지지 않고 해제하지않는다면 내부적으로는 계속 돌고있기때문에 성능에 악영향을 끼칠 수 있습니다 .

      

5. ### Updating

   1. props or state가 변경되는 경우 갱신이 발생됩니다, 여기에 해당하는 메서드들은 컴포넌트가 다시 렌더링 될 때 순서대로 호출됩니다.
   2. UNSFAE_componentWillReceiveProps()  ==> 변경 Static getDerivedStateFromProps()
      1. 여기는 state의 변경에 반응하지 않습니다
         1. 여기서 props의 값에 따라 State를 변경해야 한다면, setState를 이용해 state를 변경합니다.
         2. 그러면 다음 이벤트로 각각 가는것이 아니라 한번에 변경됩니다.
   3. UNSAFE_componentWillUpdate()  ==> 변경 shouldComponentUpdate()
      1. Props나 state둘중에 하나 혹은 둘다 변경되어도 newProps와 newState를 인자로 해서 호출합니다.
      2. Return type은 boolean 입니다.
         1. true일 경우 render를 호출하고 false의 경우 호출하지 않습니다
         2. 이 함수를 구현하지 않는다면 default value는 true입니다.
   4. **render()**
   5. getSnapshotBeforeUpdate()
      1. 가장 마지막으로 렝더링된 결과가 DOM등에 반영되었을 때 호출됩니다 이 메서드를 사용하면 컴포넌트가 DOM 으로부터 스크롤 위치 등과 같은 정보를 이후 변경되기 전에 얻을 수 있습니다.
      2. 이 생명주기가 반환하는 값은 componentDidUpdate()에 인자로 전달됩니다.
      3. 이 메서드에 대한 예제는 흔치 않지만 스크롤 위치를 기억하는 등의 역할로써 쓰입니다
      4. 스냅샷 값을 반환하거나 null을 반환합니다.
   6. **componentDidUpdate()**
      1. 이 메서드는 갱신이 일어난 직후에 호출됩니다.
      2. 이 메서드는 최초 렌더링에서는 호출되지 않습니다.
      3. 컴포넌트가 갱신되었을 때 DOM을 조작하기 위하여 이 메서드를 활용하면 좋습니다. 또한, 이전과 현재의 props를 비교하여 네트워크 요청을 보내는 작업도 이 메서드에서 이루어지면 됩니다 (props가 변하지 않았다면 네트워크 요청을 보낼 필요가 없습니다).
      4. setState()를 즉시 호출할 수도 있지만, 조건문으로 감싸지않으면 무한 반복될 가능성이 있다는 점에 주의해야합니다.
      5. 또 상위에서 내려온 prop을 그대로 state에 저장하는 것은 좋지 않으며, 그 대신 prop을 직접 사용하는 것이 좋습니다. 
      6. 컴포넌트에서 getSnapshotBeforeUpdate()를 구현한다면, 해당 메서드가 반환하는 값은 componentDidUpdate()에 세번째 "snapshot" 인자로 넘겨집니다. 반환값이 없다면 해당 인자는 undefined를 가집니다.

6. ### Unmounting

   1. 여기해당하는 메서드는 컴포넌트가 DOM 상에서 제거될 때에 호출됩니다.
   2. **componentWillUnmount()**

## Hooks 이전엔 어땠을까

1. Hooks가 나오기 이전엔 class컴포넌트나 function 컴포넌트를 다음과 같은 기준으로 나눠서 섞어서 사용해왔습니다.
2. 컴포넌트 내부에 상태가 있다면?
   1. class
3. 컴포넌트 내부에 상태가 없다면?
   1. 라이프사이클을 사용해야 한다면?
      1. Class
   2. 라이프사이클이 필요 없다면?
      1. function
4. 즉 기존에 function 컴포넌트 경우에는 상태를 관리하지도 라이프사이클을 사용하지도 못했습니다.
5. 하지만 class 컴포넌트라고 해도 단점은 존재했습니다.
   1. class 컴포넌트의 경우는 this바인딩을 정확하게 인지해야하고 또 상태 관련된 로직이 한 공간에 있기 때문에 컴포넌트들을 작게 만드는 것이 불가능하고 또한 테스트하기 어려웠습니다
   2.  이러한 단점을 보완하고자 Hook이 나왔고 이를 통해 **로직에 기반을 둔 작은 함수로 컴포넌트를 나눌 수 있게 되었습니다.**

## Hooks에서의 라이프사이클 관리

1. 리액트에서는 이렇게 설명합니다

2. Class 생명주기 메서드에 친숙하다면 , useEffect Hook을 

3. componentDidMount, componentDidUpdate, componentWillUnmount가 합쳐진 것으로 생각해도 좋습니다.

4. 클래스 컴포넌트와 비교하자면 클래스 컴포넌트는 각 생명주기 메서드들을 이용해서 시점에 맞는 처리를 할 수 있지만

5. Hooks에서는 useEffect hook이 위에 3가지 생명주기 메서드가 합쳐진 것처럼 사용해서 시점에 맞는 처리를 할 수 있습니다.

6. 먼저 Hook을 사용해 예시를 하나 만들어 보겠습니다.

7. <img width="505" alt="스크린샷 2020-12-24 오후 5 03 30" src="https://user-images.githubusercontent.com/75972718/103073005-1fad4b00-460a-11eb-960d-e211fd8c66b9.png">

8. ### useEffect의 역할

   1. useEffect Hook은 리액트에게 컴포넌트가 렌더링 이후에 어떤일을 수행해야하는지를 말합니다.
   2. 리액트는 우리가 넘긴 함수를 기억했다가(이 함수를 'effect'라고 부릅니다) DOM 업데이트를 수행한 이후에 불러낼 것입니다. 위의 경우에는 effect를 통해 문서의 title을 지정하지만 이외에도 데이터를 가져오거나 다른 API를 불러내는 일도 할 수 있습니다.

9. ### useEffect를 컴포넌트 안에서 불러내는 이유

   1. useEffect를 컴포넌트 내부에 둠으로써 effect를 통해 배열 디스트럭처링으로 선언된 변수에 접근할 수 있게 됩니다.
   2. 함수 범위 안에 존재하기 때문에 특별한 API 없이도 값을 얻을 수 있는 것입니다 Hook은 자바스크립트의 클로저를 이용하여 리액트에 한정된 API를 고안하는 것보다 자바스크립트가 이미 가지고 있는 방법을 이용하여 문제를 해결합니다.

10. ### useEffect는 렌더링 이후에 매번 수행됩니다.

    1. 마운팅과 업데이트라는 방식으로 생각하는 대신 effect를 렌더링 이후에 발생하는것으로 생각하는 것이 더 쉬울 것입니다.
    2. 리액트는 effect가 수행되는 시점에 이미 DOM이 업데이트 되었음을 보장합니다.

## 위 코드에 대한 상세한 설명

1. const state 변수를 선언한 뒤 리액트에게 effect를 사용함을 말하고 있습니다.
2. useEffect Hook에 함수를 전달하고 있는데 이 함수가 바로 effect 입니다.
3. 이 effect 내부에서 document.title이라는 브라우저 API를 이용해서 문서 타이틀을 지정합니다.
4. 같은 함수 내부에 있기 때문에 최신의 count를 바로 얻을 수 있습니다. 
5. 컴포넌트를 렌더링할 때 리액트는 우리가 이용한 effect를 기억하였다가 DOM을 업데이트한 이후에 실행합니다.
6. 이는 맨 첫 번째 렌더링은 물론 그 이후의 모든 렌더링에 똑같이 적용됩니다.
7. 













먼저 Hooks가 나오기 전에는 어땠는지 살펴보겠습니다

컴포넌트 내부에 상태가 있다면?

class

컴포넌트 내부에 상태가 없다면?

라이프 사이클을 사용해야한다면

class

라이프 사이클에 관계 없다면 Function 

즉 기존에 function 컴포넌트 경우에는 상태를 관리하지도 라이프사이클을 사용하지도 못했습니다

하지만 기존에 Class 컴포넌트의 경우는 this바인딩을 정확하게 인지해야하고 또 상태 관련된 로직이 한 공간에 있기 때문에 컴포넌트들을 작게 만드는 것이 불가능하고 또한 테스트하기 어려웠습니다 이러한 단점을 보완하고자 Hook이 나왔고 이를 통해 로직에 기반을 둔 작은 함수로 컴포넌트를 나눌 수 있게 되었습니다.



기존의 라이프 사이클

바뀐 라이프 사이클 바뀐 부분, 바뀐 이유

훅에서 useEffect가 function 컴포넌트에서 마운트 사이클을 사용할 수 없기 떄문에 생겨났는데 100% 일치하지가 않는다 그럼 일치하는 부분과 일치하지 않는 부분이 무엇인지 

